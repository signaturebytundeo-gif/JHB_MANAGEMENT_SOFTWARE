---
phase: 02-production-quality-control
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/actions/production.ts
  - src/app/(dashboard)/dashboard/production/new/page.tsx
  - src/components/production/BatchForm.tsx
  - src/components/production/AllocationFields.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a production batch with auto-generated MMDDYY batch code"
    - "User can select In-House or Co-Packer as production source"
    - "Selecting Co-Packer shows partner dropdown, lot number field, and receiving date"
    - "User can optionally allocate batch quantities to locations at creation (must sum to total)"
    - "Batch creation form is usable on mobile phone (16px inputs, large touch targets)"
    - "Failed QC via server action places batch on Hold and prevents inventory release"
    - "Batch records cannot be deleted (server action only does soft delete)"
  artifacts:
    - path: "src/app/actions/production.ts"
      provides: "Server Actions for all production operations"
      exports: ["createBatch", "submitQCTest", "updateBatchStatus"]
    - path: "src/components/production/BatchForm.tsx"
      provides: "Mobile-optimized batch creation form with conditional co-packer fields"
      min_lines: 80
    - path: "src/components/production/AllocationFields.tsx"
      provides: "Dynamic location allocation fields with sum validation"
      min_lines: 40
    - path: "src/app/(dashboard)/dashboard/production/new/page.tsx"
      provides: "Batch creation page route"
      min_lines: 15
  key_links:
    - from: "src/components/production/BatchForm.tsx"
      to: "src/app/actions/production.ts"
      via: "useActionState with createBatch"
      pattern: "useActionState.*createBatch"
    - from: "src/app/actions/production.ts"
      to: "src/lib/utils/batch-code.ts"
      via: "generateBatchCode call inside createBatch"
      pattern: "generateBatchCode"
    - from: "src/app/actions/production.ts"
      to: "src/lib/validators/production.ts"
      via: "Zod schema validation"
      pattern: "createBatchSchema.safeParse"
    - from: "src/app/actions/production.ts"
      to: "src/lib/dal.ts"
      via: "verifySession for auth"
      pattern: "verifySession|verifyManagerOrAbove"
---

<objective>
Build all production Server Actions and the mobile-optimized batch creation form with conditional co-packer fields and optional location allocation.

Purpose: This is the core creation flow -- the primary user action in production tracking. Anthony needs to create batches quickly on his phone at the restaurant. Server Actions handle the complete lifecycle: creating batches, submitting QC tests, updating status, and enforcing immutability.
Output: Working batch creation form at /dashboard/production/new, all production server actions.
</objective>

<execution_context>
@/Users/rfmstaff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rfmstaff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-production-quality-control/02-01-SUMMARY.md
@src/app/actions/auth.ts
@src/lib/dal.ts
@src/lib/db.ts
@src/lib/validators/production.ts
@src/lib/utils/batch-code.ts
@src/components/auth/LoginForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create all production Server Actions</name>
  <files>src/app/actions/production.ts</files>
  <action>
Create `src/app/actions/production.ts` following the exact pattern from `src/app/actions/auth.ts`:
- 'use server' directive at top
- Import db, validators, dal functions, generateBatchCode

**Server Actions to create:**

1. `createBatch(prevState: CreateBatchFormState, formData: FormData): Promise<CreateBatchFormState>`
   - Call `verifySession()` to get current user (batch creation should be available to ADMIN and MANAGER roles -- use `verifyManagerOrAbove()`)
   - Extract and validate form data using `createBatchSchema.safeParse()`
   - FormData extraction: productId, productionDate, productionSource, totalUnits, notes, coPackerPartnerId, coPackerLotNumber, coPackerReceivingDate
   - For allocations, extract from FormData by reading `allocation_locationId_N` and `allocation_quantity_N` fields (where N is index), build array, pass to validator
   - Generate batch code using `generateBatchCode(productionDate)`
   - Use `db.$transaction()` to atomically:
     a. Create the Batch record with status PLANNED, createdById from session
     b. If allocations provided and non-empty, create BatchAllocation records
   - On success, redirect to `/dashboard/production/${newBatch.id}` using `redirect()` from next/navigation
   - On error, return `{ message: 'Failed to create batch' }`

2. `submitQCTest(prevState: QCTestFormState, formData: FormData): Promise<QCTestFormState>`
   - Call `verifyManagerOrAbove()`
   - Validate with `qcTestSchema.safeParse()`
   - Create QCTest record with testedById from session
   - If testType is "pH" and phLevel >= 4.6, auto-set passed to false (food safety)
   - After creating test, update batch status:
     - If passed is false: set batch status to HOLD
     - If passed is true and all required QC tests pass (both pH and visual_taste exist and passed): set batch status to RELEASED
     - Otherwise: keep batch in QC_REVIEW
   - Use `revalidatePath('/dashboard/production')` after mutation
   - Return `{ success: true, message: 'QC test recorded' }`

3. `updateBatchStatus(prevState: any, formData: FormData): Promise<{ message?: string; success?: boolean }>`
   - Call `verifyManagerOrAbove()`
   - Validate with `updateBatchStatusSchema.safeParse()`
   - Enforce valid transitions:
     - PLANNED -> IN_PROGRESS only
     - IN_PROGRESS -> QC_REVIEW only
     - QC_REVIEW -> RELEASED or HOLD (via QC test results only, not manual)
     - RELEASED -> no transitions allowed
     - HOLD -> QC_REVIEW (for re-testing)
   - Update batch status
   - `revalidatePath('/dashboard/production')`

4. `getBatches(filters?: { status?: string; productId?: string; source?: string; dateFrom?: Date; dateTo?: Date })` — NOT a form action, just an async function
   - No prevState/formData pattern, just a direct async function
   - Build Prisma where clause from filters
   - Always include `isActive: true` (PROD-14 -- never show soft-deleted)
   - Include product, coPackerPartner, createdBy, qcTests, allocations with locations
   - Order by productionDate desc
   - Return typed batch array

5. `getBatchById(id: string)` — async function
   - Fetch single batch with all relations (product, coPackerPartner, createdBy, qcTests with testedBy, allocations with location, materials with rawMaterial)
   - Filter `isActive: true`
   - Return null if not found

6. `getProductionMetrics(month?: Date)` — async function for capacity metrics
   - Default to current month
   - Count total units from RELEASED batches in the given month
   - Calculate utilization percentage vs 15,000 target (hard-coded for Phase 2)
   - Return `{ totalUnits, target: 15000, utilizationPercent, batchCount }`

IMPORTANT: Import `revalidatePath` from 'next/cache' and `redirect` from 'next/navigation'. Use the same error handling pattern as auth.ts (try/catch with console.error).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify the file exports all 6 functions. Check that `verifyManagerOrAbove` is used for mutations and `verifySession` pattern is consistent with auth.ts.
  </verify>
  <done>
All 6 production functions exist: createBatch, submitQCTest, updateBatchStatus, getBatches, getBatchById, getProductionMetrics. TypeScript compilation passes. Auth checks use verifyManagerOrAbove. Batch code generation and transaction are wired correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mobile-optimized batch creation form with conditional co-packer fields</name>
  <files>src/app/(dashboard)/dashboard/production/new/page.tsx, src/components/production/BatchForm.tsx, src/components/production/AllocationFields.tsx</files>
  <action>
**File 1: `src/components/production/AllocationFields.tsx`** (client component)

Create a dynamic allocation fields component:
- Props: `locations: { id: string; name: string }[]`, `totalUnits: number`
- Use `useState` for managing allocation rows
- "Add Location" button adds a new row with location select + quantity input
- Show running total and remaining units: "Allocated: X / Y total (Z remaining)"
- Highlight in red if sum exceeds totalUnits
- Each row has a remove button (X icon)
- Each row renders: shadcn Select for location (from props) + Input for quantity
- Use `inputMode="numeric"` on quantity inputs for mobile number pad
- FormData field naming convention: hidden inputs with names `allocation_locationId_0`, `allocation_quantity_0`, etc. (indexed)
- Touch-friendly: h-11 min height on all interactive elements
- Prevent selecting the same location twice (filter already-selected from dropdown)

**File 2: `src/components/production/BatchForm.tsx`** (client component)

Create the batch creation form following existing patterns (see LoginForm.tsx for useActionState pattern):
- 'use client' directive
- Import `useActionState` from 'react' and `useFormStatus` from 'react-dom'
- Import `createBatch` from `@/app/actions/production`
- Props: `products: { id: string; name: string; sku: string }[]`, `coPackerPartners: { id: string; name: string }[]`, `locations: { id: string; name: string }[]`
- Use `useActionState(createBatch, undefined)` for form state
- Use a ref or state to track `productionSource` for conditional rendering

Form layout (mobile-first, single column):
1. **Production Date** — Input type="date", defaults to today, `text-base` for iOS
2. **Product** — shadcn Select with product name + SKU
3. **Production Source** — Two large toggle buttons (not a select): "In-House" and "Co-Packer", styled with active state highlight. Use hidden input to submit the value.
4. **Co-Packer Fields** (conditionally shown when source = CO_PACKER):
   - Partner — shadcn Select from coPackerPartners prop
   - Partner Lot Number — Input text
   - Receiving Date — Input type="date"
5. **Total Units** — Input with `inputMode="numeric"`, `text-base`
6. **Notes** — Textarea (optional), `text-base`
7. **Location Allocation** (optional section):
   - Collapsible section with "Allocate to Locations" toggle/checkbox
   - When expanded, render `AllocationFields` component
8. **Submit Button** — Full width, large (h-12), shows "Creating..." with disabled state during submission via `useFormStatus`

Mobile optimization (PROD-11):
- All inputs use `text-base` (16px) to prevent iOS auto-zoom
- Touch targets minimum h-11 (44px)
- Single column layout, generous spacing (space-y-4)
- Large submit button (h-12)
- Use `inputMode="numeric"` on number fields for mobile keyboard

Error display: Show validation errors below each field (matching LoginForm pattern). Show general error message at top if present.

Use shadcn/ui components: Input, Select (SelectTrigger, SelectContent, SelectItem, SelectValue), Button, Label, Card.

**File 3: `src/app/(dashboard)/dashboard/production/new/page.tsx`** (server component)

Create the page that wraps BatchForm:
- Import from dal.ts to verify session (server component)
- Fetch products: `db.product.findMany({ where: { isActive: true }, select: { id, name, sku } })`
- Fetch co-packer partners: `db.coPackerPartner.findMany({ where: { isActive: true }, select: { id, name } })`
- Fetch locations: `db.location.findMany({ where: { isActive: true }, select: { id, name } })`
- Pass data as props to BatchForm
- Page header: "New Production Batch" with back link to /dashboard/production
- Wrap in Card component for visual containment

IMPORTANT: Do NOT use react-hook-form with useForm() here. Follow the existing codebase pattern of using React 19 useActionState + native form + FormData. The shadcn form.tsx (which uses react-hook-form Controller) is available but the codebase pattern for server actions uses the simpler useActionState approach. Match the LoginForm.tsx pattern.
  </action>
  <verify>
1. Navigate to /dashboard/production/new in browser — form renders with all fields
2. Selecting "Co-Packer" source shows partner dropdown, lot number, and receiving date fields
3. Selecting "In-House" hides co-packer fields
4. "Allocate to Locations" section expands/collapses and shows allocation rows
5. Form submits and creates a batch in the database (check via Prisma Studio: `npx prisma studio`)
6. On mobile viewport (375px width in dev tools), inputs are 16px+ and touch targets are 44px+
7. `npx tsc --noEmit` passes
  </verify>
  <done>
Batch creation form renders at /dashboard/production/new. Product select, source toggle, conditional co-packer fields, total units, notes, and optional allocation all work. Form submits via Server Action and creates batch with auto-generated MMDDYY code. Mobile-optimized with 16px inputs and 44px touch targets. TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
1. Navigate to /dashboard/production/new — form loads with products, partners, locations
2. Create a batch with In-House source — batch appears in database with MMDDYY code
3. Create a second batch same day — code gets letter suffix (e.g., 021726A)
4. Create a batch with Co-Packer source — co-packer fields visible and data saved
5. Create a batch with location allocations — allocations saved and sum matches total
6. Mobile viewport shows clean single-column layout with no iOS zoom issues
7. All TypeScript files compile without errors
</verification>

<success_criteria>
- Batch creation form works end-to-end: form -> Server Action -> database -> redirect
- MMDDYY batch codes auto-generate with letter suffixes for same-day batches
- Co-packer fields conditionally show/hide based on production source selection
- Location allocations are optional and validate sum equals total units
- Form is mobile-optimized (16px inputs, 44px touch targets, single column)
- QC test submission, status updates, and query functions all pass TypeScript check
</success_criteria>

<output>
After completion, create `.planning/phases/02-production-quality-control/02-02-SUMMARY.md`
</output>
