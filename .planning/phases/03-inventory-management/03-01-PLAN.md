---
phase: 03-inventory-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/seed.ts
  - src/lib/validators/inventory.ts
  - src/lib/utils/fifo.ts
  - src/lib/utils/reorder-point.ts
autonomous: true

must_haves:
  truths:
    - "InventoryMovement model exists with movementType enum, batch/location relations, approval fields, and quantity CHECK constraint"
    - "PackagingMaterial model exists with type, supplier, quantity, reorderPoint, and leadTimeDays fields"
    - "Product model has reorderPoint and leadTimeDays fields for reorder alert calculations"
    - "FIFO allocation utility selects oldest RELEASED batches first and throws on insufficient inventory"
    - "Reorder point utility calculates threshold from average daily demand, lead time, and safety stock"
    - "Zod schemas validate transfer, adjustment, and packaging material forms with cross-field refinements"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "InventoryMovement model, PackagingMaterial model, MovementType and AdjustmentReason enums, Product reorder fields"
      contains: "model InventoryMovement"
    - path: "src/lib/validators/inventory.ts"
      provides: "transferSchema, adjustmentSchema, packagingMaterialSchema with form state types"
      exports: ["transferSchema", "adjustmentSchema", "packagingMaterialSchema"]
    - path: "src/lib/utils/fifo.ts"
      provides: "FIFO allocation algorithm that returns batch-quantity pairs"
      exports: ["allocateInventoryFIFO"]
    - path: "src/lib/utils/reorder-point.ts"
      provides: "Reorder point calculation and stock level classification"
      exports: ["calculateReorderPoint", "classifyStockLevel"]
  key_links:
    - from: "src/lib/utils/fifo.ts"
      to: "prisma/schema.prisma"
      via: "Queries Batch with status RELEASED, ordered by productionDate asc"
      pattern: "status.*RELEASED.*orderBy.*productionDate.*asc"
    - from: "src/lib/validators/inventory.ts"
      to: "prisma/schema.prisma"
      via: "AdjustmentReason enum values match Zod enum"
      pattern: "DAMAGE.*SHRINKAGE.*SAMPLING.*EXPIRED"
---

<objective>
Create the database foundation and utility layer for Phase 3 inventory management.

Purpose: All inventory features (stock levels, transfers, adjustments, packaging tracking, valuation) depend on the InventoryMovement event-sourcing model, FIFO allocation algorithm, and validation schemas. This plan establishes that shared foundation.

Output: Updated Prisma schema with InventoryMovement + PackagingMaterial models, Zod validators for inventory forms, FIFO allocation utility, and reorder-point calculation utility.
</objective>

<execution_context>
@/Users/rfmstaff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rfmstaff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-inventory-management/03-RESEARCH.md
@.planning/phases/02-production-quality-control/02-01-SUMMARY.md

Key existing patterns:
- Prisma schema at apps/command-center/prisma/schema.prisma has Batch, BatchAllocation, RawMaterial models
- Validators follow Zod pattern in src/lib/validators/production.ts (refine for cross-field, coerce for numbers)
- Utilities in src/lib/utils/ (batch-code.ts exists as reference)
- BatchStatus enum: PLANNED, IN_PROGRESS, QC_REVIEW, RELEASED, HOLD
- BatchAllocation tracks batchId + locationId + quantity (initial allocation at batch creation)
- date-fns already installed for date operations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InventoryMovement, PackagingMaterial models and Product reorder fields to Prisma schema</name>
  <files>prisma/schema.prisma, prisma/seed.ts</files>
  <action>
Add to prisma/schema.prisma:

1. **MovementType enum:** PRODUCTION, TRANSFER, ADJUSTMENT, ALLOCATION, DEDUCTION

2. **AdjustmentReason enum:** DAMAGE, SHRINKAGE, SAMPLING, EXPIRED, COUNT_CORRECTION

3. **InventoryMovement model:**
   - id: String @id @default(cuid())
   - movementType: MovementType
   - batchId: String (relation to Batch)
   - fromLocationId: String? (relation to Location, nullable for inbound)
   - toLocationId: String? (relation to Location, nullable for outbound)
   - quantity: Int (always positive, direction determined by from/to)
   - reason: AdjustmentReason? (required for ADJUSTMENT type)
   - notes: String?
   - requiresApproval: Boolean @default(false)
   - approvedById: String? (relation to User)
   - approvedAt: DateTime?
   - createdById: String (relation to User)
   - createdAt: DateTime @default(now())
   - Indexes on: batchId, fromLocationId, toLocationId, movementType, createdAt, createdById
   - Add relation back-references on Batch, Location, User models

4. **PackagingMaterial model:**
   - id: String @id @default(cuid())
   - name: String (e.g., "5oz Glass Bottle", "Standard Cap", "Front Label")
   - type: String (BOTTLE, CAP, LABEL, BOX, OTHER)
   - supplier: String
   - currentQuantity: Int @default(0)
   - unit: String (e.g., "units", "rolls", "sheets")
   - reorderPoint: Int @default(0)
   - leadTimeDays: Int @default(14)
   - costPerUnit: Decimal?
   - lastOrderDate: DateTime?
   - isActive: Boolean @default(true)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - Indexes on: name, type, isActive

5. **Add to Product model:**
   - reorderPoint: Int @default(0) — default reorder threshold in units
   - leadTimeDays: Int @default(14) — default production/procurement lead time

6. **Update Location model** to add inventory movement relations:
   - Add `movementsFrom InventoryMovement[] @relation("FromLocation")`
   - Add `movementsTo InventoryMovement[] @relation("ToLocation")`

7. **Update User model** to add inventory movement relations:
   - Add `createdMovements InventoryMovement[] @relation("MovementCreator")`
   - Add `approvedMovements InventoryMovement[] @relation("MovementApprover")`

8. **Update Batch model** to add:
   - `inventoryMovements InventoryMovement[]`

Use named relations on InventoryMovement for the two Location references (fromLocation/toLocation) and two User references (createdBy/approvedBy) to avoid ambiguity.

After schema changes, run `npx prisma db push` then `npx prisma generate`.

IMPORTANT: SQLite does not support CHECK constraints via Prisma schema. The quantity >= 0 constraint will be enforced at the application level in server actions (Zod validators ensure positive quantities). This avoids the SQLite ALTER TABLE limitation. If a custom migration is needed later, it can recreate the table — but for now, application-level validation is sufficient since all writes go through server actions.

In prisma/seed.ts, add seed data for common packaging materials:
- 5oz Glass Bottle (BOTTLE, units, reorderPoint: 500, leadTimeDays: 21)
- 10oz Glass Bottle (BOTTLE, units, reorderPoint: 500, leadTimeDays: 21)
- Standard Cap (CAP, units, reorderPoint: 1000, leadTimeDays: 14)
- Front Label - 5oz (LABEL, units, reorderPoint: 500, leadTimeDays: 14)
- Front Label - 10oz (LABEL, units, reorderPoint: 500, leadTimeDays: 14)
- Shipping Box - 12 pack (BOX, units, reorderPoint: 200, leadTimeDays: 7)

Also update existing Product seed data to set reorderPoint and leadTimeDays:
- All products: reorderPoint = 100 (units), leadTimeDays = 14 (days) as reasonable defaults

Run `npx tsx prisma/seed.ts` after to verify seeding works.
  </action>
  <verify>
Run these commands from apps/command-center/:
1. `npx prisma db push` — succeeds without errors
2. `npx prisma generate` — generates client with InventoryMovement, PackagingMaterial types
3. `npx tsx prisma/seed.ts` — seeds packaging materials without errors
4. `npx tsc --noEmit` — TypeScript compiles cleanly
  </verify>
  <done>
InventoryMovement model exists with MovementType enum, AdjustmentReason enum, all fields and relations. PackagingMaterial model exists with reorder tracking fields. Product model has reorderPoint and leadTimeDays fields. 6 packaging materials seeded. All products have default reorder settings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validators, FIFO allocation utility, and reorder-point utility</name>
  <files>src/lib/validators/inventory.ts, src/lib/utils/fifo.ts, src/lib/utils/reorder-point.ts</files>
  <action>
**src/lib/validators/inventory.ts:**

Create Zod schemas following the pattern in src/lib/validators/production.ts:

1. `transferSchema` — z.object with:
   - productId: z.string().min(1)
   - fromLocationId: z.string().min(1)
   - toLocationId: z.string().min(1)
   - quantity: z.coerce.number().int().positive()
   - notes: z.string().optional()
   - .refine() to ensure fromLocationId !== toLocationId

2. `adjustmentSchema` — z.object with:
   - batchId: z.string().min(1)
   - locationId: z.string().min(1)
   - quantityChange: z.coerce.number().int().refine(val => val !== 0, 'Change cannot be zero')
   - reason: z.nativeEnum(AdjustmentReason) — import from @prisma/client (use z.enum with the string values if nativeEnum doesn't work with SQLite enums: z.enum(['DAMAGE', 'SHRINKAGE', 'SAMPLING', 'EXPIRED', 'COUNT_CORRECTION']))
   - notes: z.string().optional()

3. `packagingMaterialSchema` — z.object with:
   - name: z.string().min(1).max(100)
   - type: z.enum(['BOTTLE', 'CAP', 'LABEL', 'BOX', 'OTHER'])
   - supplier: z.string().min(1)
   - currentQuantity: z.coerce.number().int().min(0)
   - unit: z.string().min(1)
   - reorderPoint: z.coerce.number().int().min(0)
   - leadTimeDays: z.coerce.number().int().min(1)
   - costPerUnit: z.coerce.number().min(0).optional()

4. Export form state types: TransferFormState, AdjustmentFormState, PackagingFormState — all following the pattern: `{ errors?: Record<string, string[]>; message?: string; success?: boolean } | undefined`

**src/lib/utils/fifo.ts:**

Create the FIFO allocation algorithm. This function takes a Prisma transaction client (or the default db) so it can be called inside transactions:

```typescript
import { db } from '@/lib/db';

type PrismaClient = typeof db;

export type FIFOAllocation = {
  batchId: string;
  batchCode: string;
  productionDate: Date;
  quantity: number;
};

export async function allocateInventoryFIFO(
  productId: string,
  locationId: string,
  quantityNeeded: number,
  tx: PrismaClient = db
): Promise<FIFOAllocation[]> {
  // 1. Get all RELEASED batches for this product at this location, ordered by productionDate ASC (oldest first)
  const batches = await tx.batch.findMany({
    where: {
      productId,
      status: 'RELEASED',
      allocations: { some: { locationId } }
    },
    include: {
      allocations: { where: { locationId } }
    },
    orderBy: { productionDate: 'asc' }
  });

  // 2. For each batch, calculate available = initial allocation - outbound movements + inbound movements
  const batchesWithAvailable = await Promise.all(
    batches.map(async (batch) => {
      const initialAllocation = batch.allocations[0]?.quantity || 0;

      // Sum inbound movements (toLocationId = this location, for this batch)
      const inbound = await tx.inventoryMovement.aggregate({
        where: { batchId: batch.id, toLocationId: locationId },
        _sum: { quantity: true }
      });

      // Sum outbound movements (fromLocationId = this location, for this batch)
      const outbound = await tx.inventoryMovement.aggregate({
        where: { batchId: batch.id, fromLocationId: locationId },
        _sum: { quantity: true }
      });

      const available = initialAllocation + (inbound._sum.quantity || 0) - (outbound._sum.quantity || 0);

      return {
        batchId: batch.id,
        batchCode: batch.batchCode,
        productionDate: batch.productionDate,
        available: Math.max(0, available)
      };
    })
  );

  // 3. Allocate from oldest first
  const allocations: FIFOAllocation[] = [];
  let remaining = quantityNeeded;

  for (const batch of batchesWithAvailable) {
    if (remaining <= 0) break;
    if (batch.available <= 0) continue;

    const toAllocate = Math.min(batch.available, remaining);
    allocations.push({
      batchId: batch.batchId,
      batchCode: batch.batchCode,
      productionDate: batch.productionDate,
      quantity: toAllocate
    });
    remaining -= toAllocate;
  }

  if (remaining > 0) {
    throw new Error(`Insufficient inventory: need ${quantityNeeded} units, only ${quantityNeeded - remaining} available`);
  }

  return allocations;
}
```

Also export a `getAvailableStock` helper that returns total available units for a product at a location (used by stock level grid):

```typescript
export async function getAvailableStock(
  productId: string,
  locationId: string,
  tx: PrismaClient = db
): Promise<number> {
  // Same logic as FIFO but just returns the total
  // ... sum all batch availables for this product/location
}
```

**src/lib/utils/reorder-point.ts:**

```typescript
export type StockLevel = 'HEALTHY' | 'REORDER' | 'CRITICAL';

export function calculateReorderPoint(
  averageDailyDemand: number,
  leadTimeDays: number,
  safetyStockDays: number = 7
): number {
  const leadTimeDemand = averageDailyDemand * leadTimeDays;
  const safetyStock = averageDailyDemand * safetyStockDays;
  return Math.ceil(leadTimeDemand + safetyStock);
}

export function classifyStockLevel(
  currentStock: number,
  reorderPoint: number
): StockLevel {
  if (currentStock < reorderPoint) return 'CRITICAL';
  if (currentStock < reorderPoint * 1.2) return 'REORDER';
  return 'HEALTHY';
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` — all three new files compile without errors
2. Verify imports resolve: validators import from Zod, fifo imports from @/lib/db, reorder-point has no external deps
  </verify>
  <done>
Three utility files exist: inventory validators with transferSchema/adjustmentSchema/packagingMaterialSchema and form state types, FIFO allocation utility with allocateInventoryFIFO/getAvailableStock, and reorder-point utility with calculateReorderPoint/classifyStockLevel. All compile cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` succeeds
2. `npx prisma generate` succeeds
3. `npx tsx prisma/seed.ts` succeeds
4. `npx tsc --noEmit` passes with zero errors
5. InventoryMovement model has all required fields (movementType, batchId, fromLocationId, toLocationId, quantity, reason, requiresApproval, approvedById, approvedAt, createdById, createdAt)
6. PackagingMaterial model has reorder tracking fields (reorderPoint, leadTimeDays, currentQuantity)
7. Product model has reorderPoint and leadTimeDays fields
8. FIFO utility exports allocateInventoryFIFO and getAvailableStock
9. Reorder utility exports calculateReorderPoint and classifyStockLevel
</verification>

<success_criteria>
- InventoryMovement model with MovementType enum enables event-sourced audit trail for all inventory changes
- PackagingMaterial model with reorder fields enables packaging tracking with supply alerts
- Product reorder fields enable stock level classification
- FIFO allocation utility correctly selects oldest RELEASED batches first
- Zod validators enforce form-level validation for transfers, adjustments, and packaging materials
- All code compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-inventory-management/03-01-SUMMARY.md`
</output>
