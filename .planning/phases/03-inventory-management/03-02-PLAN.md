---
phase: 03-inventory-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/app/actions/inventory.ts
  - src/app/(dashboard)/dashboard/inventory/page.tsx
  - src/components/inventory/StockLevelGrid.tsx
  - src/components/inventory/InventoryAlertBadge.tsx
autonomous: true

must_haves:
  truths:
    - "User sees real-time stock levels for every SKU at every location with color-coded alerts"
    - "Stock levels are computed from BatchAllocation initial quantities plus/minus InventoryMovement events"
    - "Color coding shows green (healthy), yellow (reorder), red (critical) based on reorder point"
    - "System prevents negative inventory by validating available stock before any deduction"
    - "All inventory movements create immutable audit trail entries"
  artifacts:
    - path: "src/app/actions/inventory.ts"
      provides: "Server actions for stock queries, transfers, adjustments, and audit trail"
      exports: ["getStockLevels", "getAuditTrail", "transferInventory", "createAdjustment", "approveAdjustment"]
    - path: "src/app/(dashboard)/dashboard/inventory/page.tsx"
      provides: "Inventory dashboard server component with stock level data"
      min_lines: 20
    - path: "src/components/inventory/StockLevelGrid.tsx"
      provides: "Color-coded inventory grid with product rows and location columns"
      min_lines: 50
    - path: "src/components/inventory/InventoryAlertBadge.tsx"
      provides: "CVA-based badge with HEALTHY/REORDER/CRITICAL variants"
      min_lines: 20
  key_links:
    - from: "src/app/(dashboard)/dashboard/inventory/page.tsx"
      to: "src/app/actions/inventory.ts"
      via: "Server component calls getStockLevels()"
      pattern: "getStockLevels"
    - from: "src/components/inventory/StockLevelGrid.tsx"
      to: "src/components/inventory/InventoryAlertBadge.tsx"
      via: "Renders badge for each SKU/location cell"
      pattern: "InventoryAlertBadge"
    - from: "src/app/actions/inventory.ts"
      to: "src/lib/utils/fifo.ts"
      via: "Transfer and adjustment actions use FIFO allocation"
      pattern: "allocateInventoryFIFO"
---

<objective>
Build the inventory server actions and real-time stock levels dashboard with color-coded alerts.

Purpose: This is the core inventory visibility layer — the main inventory page shows every SKU at every location with green/yellow/red status. The server actions created here are also used by Plan 03 (transfer/adjustment UI) and Plan 04 (valuation report). This satisfies INV-01 (stock levels), INV-02 (color coding), INV-09 (audit trail write path), and INV-10 (negative prevention logic).

Output: inventory.ts server actions file with all mutation/query actions, inventory dashboard page with StockLevelGrid, and InventoryAlertBadge component.
</objective>

<execution_context>
@/Users/rfmstaff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rfmstaff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-inventory-management/03-RESEARCH.md
@.planning/phases/03-inventory-management/03-01-SUMMARY.md

Key existing patterns from Phase 2:
- Server actions: src/app/actions/production.ts uses 'use server', verifyManagerOrAbove(), Zod validation, revalidatePath
- Form state pattern: { errors?: Record<string, string[]>; message?: string; success?: boolean } | undefined
- DAL: src/lib/dal.ts exports verifySession, verifyAdmin, verifyManagerOrAbove
- Database: src/lib/db.ts exports db (Prisma client)
- CVA badges: src/components/ui/badge.tsx exists with success/warning/destructive variants
- Responsive pattern: table on desktop, cards on mobile (from RawMaterialList.tsx)

Files from Plan 01 this depends on:
- prisma/schema.prisma (InventoryMovement, PackagingMaterial models, MovementType enum)
- src/lib/validators/inventory.ts (transferSchema, adjustmentSchema, form state types)
- src/lib/utils/fifo.ts (allocateInventoryFIFO, getAvailableStock)
- src/lib/utils/reorder-point.ts (classifyStockLevel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inventory server actions for stock queries, transfers, adjustments, and audit trail</name>
  <files>src/app/actions/inventory.ts</files>
  <action>
Create src/app/actions/inventory.ts with 'use server' directive. Follow the pattern established in src/app/actions/production.ts.

**Query actions (no auth mutation, just read):**

1. `getStockLevels()` — Returns stock for every product at every location.
   - Fetch all active products with their reorderPoint field
   - Fetch all active locations
   - For each product/location pair, compute current stock:
     - Initial: sum of BatchAllocation.quantity for RELEASED batches of this product at this location
     - Plus: sum of InventoryMovement.quantity where toLocationId = location AND batch.productId = product AND approvedAt is not null (only count approved movements)
     - Minus: sum of InventoryMovement.quantity where fromLocationId = location AND batch.productId = product AND approvedAt is not null
   - Optimize: do ONE query to get all movements, then aggregate in memory (avoid N*M queries). Use Prisma findMany with include batch.productId, then group in JS.
   - Return: Array of { product: { id, name, sku, size, reorderPoint }, locations: Array<{ location: { id, name, type }, quantity: number, stockLevel: StockLevel }> }
   - Use classifyStockLevel from reorder-point.ts for each cell

2. `getAuditTrail(filters?)` — Returns paginated movement history.
   - Optional filters: productId, locationId, movementType, dateRange
   - Include: batch (batchCode, product name), fromLocation name, toLocation name, createdBy name, approvedBy name
   - Order by createdAt desc
   - Return last 100 movements (pagination can be added later)

**Mutation actions (require auth):**

3. `transferInventory(prevState, formData)` — Transfer units between locations.
   - Verify session with verifyManagerOrAbove()
   - Validate with transferSchema from validators/inventory.ts
   - Use db.$transaction:
     a. Call allocateInventoryFIFO(productId, fromLocationId, quantity, tx) to get FIFO batch allocations
     b. For each allocation, create TWO InventoryMovement records:
        - Outbound: movementType TRANSFER, fromLocationId set, toLocationId null, quantity, createdById, approvedById (auto-approve transfers), approvedAt now
        - Inbound: movementType TRANSFER, fromLocationId null, toLocationId set, quantity, createdById, approvedById, approvedAt now
     c. Both records share the same batchId (preserves FIFO — the destination gets the same batch association)
   - revalidatePath('/dashboard/inventory')
   - Return success/error form state

4. `createAdjustment(prevState, formData)` — Adjust inventory with reason code.
   - Verify session with verifyManagerOrAbove()
   - Validate with adjustmentSchema
   - Calculate variance: |quantityChange| / currentStock * 100
   - If variance > 2%: create movement with requiresApproval = true, approvedById = null, approvedAt = null
   - If variance <= 2%: create movement auto-approved (approvedById = userId, approvedAt = now)
   - For positive adjustment: toLocationId = locationId, fromLocationId = null
   - For negative adjustment: fromLocationId = locationId, toLocationId = null
   - Quantity is always Math.abs(quantityChange)
   - revalidatePath('/dashboard/inventory')
   - Return message indicating whether approval is required

5. `approveAdjustment(movementId)` — Approve a pending adjustment.
   - Verify session with verifyAdmin() (dual approval = different person, but for now Admin-only)
   - Find the movement, verify it requiresApproval and is not yet approved
   - Verify approver is different from creator (createdById !== session.userId)
   - Update: approvedById = session.userId, approvedAt = now
   - revalidatePath('/dashboard/inventory')

6. `getProductsForTransfer()` — Returns products with available stock summary (for transfer form dropdowns)
   - Returns active products with their total stock across all locations

7. `getLocationsForTransfer()` — Returns active locations (for transfer form dropdowns)

IMPORTANT: Only count APPROVED movements in stock calculations. Movements with requiresApproval=true and approvedAt=null should NOT affect stock levels until approved. This prevents unapproved adjustments from showing in stock.
  </action>
  <verify>
1. `npx tsc --noEmit` — compiles without errors
2. Verify the file exports all 7 functions
3. Verify transferInventory uses db.$transaction
4. Verify getStockLevels filters by approvedAt is not null
  </verify>
  <done>
inventory.ts server actions file exists with getStockLevels, getAuditTrail, transferInventory, createAdjustment, approveAdjustment, getProductsForTransfer, getLocationsForTransfer. Transfer uses FIFO allocation within transaction. Adjustments auto-approve below 2% variance. Stock calculations exclude unapproved movements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build inventory dashboard page with StockLevelGrid and InventoryAlertBadge</name>
  <files>src/app/(dashboard)/dashboard/inventory/page.tsx, src/components/inventory/StockLevelGrid.tsx, src/components/inventory/InventoryAlertBadge.tsx</files>
  <action>
**src/components/inventory/InventoryAlertBadge.tsx:**

Create a CVA-based badge component following the existing badge pattern in src/components/ui/badge.tsx:

```typescript
import { cva } from 'class-variance-authority';
import type { StockLevel } from '@/lib/utils/reorder-point';

const alertVariants = cva(
  'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold',
  {
    variants: {
      level: {
        HEALTHY: 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400',
        REORDER: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',
        CRITICAL: 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400',
      },
    },
  }
);
```

Props: currentStock (number), stockLevel (StockLevel). Renders quantity with colored background.

**src/components/inventory/StockLevelGrid.tsx:**

Client component ('use client') that receives stock level data as props.

Layout:
- Desktop (lg+): Data table with product rows and a quantity column per location. Each cell shows the quantity with InventoryAlertBadge coloring. Product column shows name + SKU + size.
- Mobile: Card layout per product, showing each location as a row within the card with stock level badge.

Features:
- Filter by product (dropdown or search input)
- Filter by stock level (All / Critical / Reorder / Healthy)
- Sort by product name or total stock
- Show total across all locations per product in a "Total" column
- If a product has zero stock everywhere, still show it (important for visibility)
- Empty state: "No inventory data. Create batches and allocate to locations in Production."

Props type:
```typescript
type StockLevelData = {
  product: { id: string; name: string; sku: string; size: string; reorderPoint: number };
  locations: Array<{
    location: { id: string; name: string; type: string };
    quantity: number;
    stockLevel: StockLevel;
  }>;
  total: number;
}[];
```

Use the responsive table-to-cards pattern from Phase 2 (RawMaterialList). Use existing UI components (Input for search, Button, Badge).

**src/app/(dashboard)/dashboard/inventory/page.tsx:**

Replace the placeholder page. Make it a Server Component:

1. Call verifyManagerOrAbove() for access control (or verifySession() if Sales Reps should see inventory too — use verifySession since viewing stock is read-only)
2. Call getStockLevels() from actions/inventory.ts
3. Render page header: "Inventory Management" with subtitle
4. Add navigation tabs/links to sub-pages: Stock Levels (current), Transfers, Adjustments, Packaging, Audit Trail
5. Render StockLevelGrid with data
6. Add a summary row at top: total SKUs, total units across all locations, number of critical/reorder items

Use Tailwind classes consistent with existing dashboard pages. Follow the same heading/spacing pattern as the production page.
  </action>
  <verify>
1. `npx tsc --noEmit` — all new files compile
2. Visit /dashboard/inventory in browser — shows stock level grid (may be empty if no released batches exist, but should render without errors)
3. InventoryAlertBadge renders green/yellow/red correctly
4. Mobile view shows card layout instead of wide table
  </verify>
  <done>
Inventory dashboard page shows real-time stock levels for every SKU at every location. Each cell has color-coded badge (green healthy, yellow reorder, red critical). Grid supports filtering by product and stock level. Mobile responsive with card layout. Sub-page navigation links present for transfers, adjustments, packaging, and audit trail.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. inventory.ts exports getStockLevels, getAuditTrail, transferInventory, createAdjustment, approveAdjustment
3. /dashboard/inventory renders stock level grid with color-coded badges
4. StockLevelGrid filters by product and stock level work
5. Mobile responsive layout renders cards instead of table
6. transferInventory uses db.$transaction with FIFO allocation
7. createAdjustment flags >2% variance for approval
8. Stock calculations exclude unapproved movements
</verification>

<success_criteria>
- INV-01: User sees real-time stock levels for every SKU at every location
- INV-02: Color coding (green/yellow/red) based on reorder point thresholds
- INV-09: Server actions create immutable InventoryMovement records for every change
- INV-10: Transfer action validates available stock before deduction (throws on insufficient)
- Stock levels computed correctly from BatchAllocation + InventoryMovement aggregation
- All server actions follow established Phase 2 patterns (Zod validation, session verification, revalidatePath)
</success_criteria>

<output>
After completion, create `.planning/phases/03-inventory-management/03-02-SUMMARY.md`
</output>
